# 全语音AI-Agent平台 后端开发文档

**技术栈**：Python 3.9+，FastAPI，Uvicorn，SQLAlchemy，Alembic，Pydantic，PyMySQL，JWT，OpenAI Python SDK，aiohttp，loguru，pytest

---

## 目录
1. 概览
2. 项目结构
3. 环境与依赖管理
4. 配置说明
5. 数据库模型与迁移
## 6. 核心服务组件
   - 6.1 路由（Routers）
   - 6.2 控制器（Controllers）
   - 6.3 服务层（Services）
   - 6.4 客户端（Clients）
   - 6.5 统一执行服务（Unified Execution Service）
7. API 接口架构
   - 认证接口：JWT认证和权限控制
   - 意图解析：解析用户输入，识别意图和参数
   - 工具执行：执行特定工具，处理用户请求
   - 工具管理：获取可用工具列表
   - 开发者接口：工具管理、上传、测试、应用管理
   - MCP管理：服务器状态管理
   - 健康检查：服务状态检查
   
   **API基础信息**：基础URL `http://localhost:3000`，认证方式 Bearer Token (JWT)，在线文档 `/docs`。详细的API接口定义请参考：[前后端对接与API规范](前后端对接与API规范.md)
8. 错误处理与日志
9. 身份认证（JWT）
10. 集成测试与单元测试
11. 本地启动与部署
12. 支持的工具类型
13. 后续迭代规划

---

## 1. 概览
该文档面向后端开发团队，覆盖从环境配置、数据库设计、核心业务流程、API 细节到测试部署的全流程。保证开发人员能"一看就会"、"对照即做"。

---

## 2. 项目结构
### 完整目录结构
```text
backend/
├── alembic/                    # 数据库迁移配置与脚本
│   ├── versions/               # 迁移版本脚本
│   ├── env.py                  # Alembic环境配置
│   └── alembic.ini             # Alembic配置文件
├── app/                        # 应用主目录
│   ├── clients/                # 第三方/内部客户端封装
│   │   ├── openai_client.py    # OpenAI/兼容LLM客户端
│   │   ├── mcp_client.py       # MCP客户端
│   │   └── http_client.py      # HTTP请求客户端
│   ├── controllers/            # 控制器：请求校验与响应封装
│   │   ├── intent_controller.py # 意图解析控制器
│   │   ├── execute_controller.py # 工具执行控制器
│   │   ├── tools_controller.py  # 工具管理控制器
│   │   └── auth_controller.py   # 认证控制器
│   ├── models/                 # SQLAlchemy ORM 模型
│   │   ├── user.py             # 用户模型
│   │   ├── tool.py             # 工具模型
│   │   ├── session.py          # 会话模型
│   │   └── log.py              # 日志模型
│   ├── routers/                # 路由模块
│   │   ├── intent.py           # /api/v1/interpret, /api/v1/confirm
│   │   ├── execute.py          # /api/v1/execute
│   │   ├── tools.py            # /api/v1/tools
│   │   ├── auth.py             # /api/v1/auth
│   │   ├── dev_tools.py        # /api/v1/dev/tools
│   │   ├── dev_apps.py         # /api/v1/dev/apps
│   │   └── mcp_status.py       # /api/v1/mcp/status
│   ├── schemas/                # Pydantic 请求/响应 schema
│   │   ├── intent.py           # 意图解析Schema
│   │   ├── execute.py          # 工具执行Schema
│   │   ├── tool.py             # 工具管理Schema
│   │   ├── auth.py             # 认证Schema
│   │   └── dev.py              # 开发者功能Schema
│   ├── services/               # 业务逻辑层
│   │   ├── intent_service.py    # 意图解析服务
│   │   ├── execute_service.py   # 工具执行服务
│   │   ├── unified_execution_service.py # 统一执行服务
│   │   ├── tool_service.py      # 工具管理服务
│   │   ├── auth_service.py      # 认证服务
│   │   ├── dev_tool_service.py  # 开发者工具服务
│   │   ├── dev_app_service.py   # 开发者应用服务
│   │   ├── mcp_manager.py       # MCP服务器管理器
│   │   └── package_parser.py    # 工具包解析服务
│   ├── utils/                  # 通用工具
│   │   ├── db.py               # SQLAlchemy engine & session
│   │   ├── logger.py           # loguru 配置
│   │   └── dependencies.py     # FastAPI 依赖注入
│   ├── config.py               # 配置管理 (.env 变量映射)
│   └── main.py                 # FastAPI 应用实例与中间件注册
├── logs/                       # 日志文件目录
├── scripts/                    # 辅助脚本
├── tests/                      # 测试代码
│   ├── test_execute_service.py # 工具执行服务测试
│   ├── test_interpret_api.py   # 意图解析API测试
│   └── test_auth.py            # 认证功能测试
├── .env.example                # 环境变量示例
├── alembic.ini                 # Alembic配置
├── requirements.txt            # 依赖包列表
└── pytest.ini                  # pytest配置
```

### 核心文件详解
- **main.py**: FastAPI应用入口，注册中间件和路由
- **config.py**: 环境变量加载和应用配置
- **services/execute_service.py**: 工具执行逻辑，支持MCP和各类HTTP工具
- **services/intent_service.py**: 意图解析逻辑，使用LLM解析用户输入
- **services/unified_execution_service.py**: 统一执行服务，整合execute和confirm接口的核心逻辑
- **clients/mcp_client.py**: MCP客户端封装，处理MCP工具调用
- **clients/http_client.py**: HTTP客户端，处理HTTP类型工具调用
- **models/tool.py**: 工具数据库模型，定义工具属性和关系

---

## 3. 环境与依赖管理
1. 安装 Python 3.9+ 环境
2. 克隆仓库并创建虚拟环境：
   ```bash
   git clone <repo_url>
   cd repo/backend
   python -m venv venv
   source venv/bin/activate  # Linux/Mac
   # 或
   venv\Scripts\activate  # Windows
   ```
3. 安装依赖：
   ```bash
   pip install -r requirements.txt
   ```
4. 完整 requirements.txt：
   ```text
   fastapi>=0.95.0
   uvicorn[standard]>=0.22.0
   sqlalchemy>=2.0.0
   pymysql>=1.0.3
   alembic>=1.11.0
   pydantic>=2.0.0
   python-dotenv>=1.0.0
   loguru>=0.7.0
   openai>=1.1.0
   anthropic>=0.3.0
   aiohttp>=3.8.5
   httpx>=0.24.0
   pytest>=7.3.1
   pytest-asyncio>=0.21.0
   python-jose>=3.3.0
   passlib>=1.7.4
   python-multipart>=0.0.6
   bcrypt>=4.0.1
   ```

---

## 4. 配置说明 (`config.py` 和 `.env`)

### 数据库配置要求
**重要**: 系统强制要求使用MySQL数据库，启动时会自动检查数据库连接可用性。

- **必须使用MySQL**: 不支持SQLite等其他数据库
- **连接检查**: 启动前自动验证数据库连接
- **配置文件**: 所有配置通过 `.env` 文件管理

### 配置类 (config.py)
```python
from pydantic_settings import BaseSettings
from pydantic import Field

class Settings(BaseSettings):
    # 应用信息
    APP_NAME: str = Field(default="AI Assistant API", env="APP_NAME")
    VERSION: str = Field(default="0.1.0", env="VERSION")
    API_PREFIX: str = Field(default="/api/v1", env="API_PREFIX")
    
    # 环境配置
    ENV: str = Field(default="development", env="ENV")
    DEBUG_STR: str = Field(default="True", env="DEBUG")
    
    # 服务器配置
    HOST: str = Field(default="0.0.0.0", env="HOST")
    PORT: int = Field(default=3000, env="PORT")
    
    # 数据库配置 - 强制要求MySQL
    DATABASE_URL: str = Field(default="sqlite:///test.db", env="DATABASE_URL")
    DATABASE_NAME: str = Field(default="ai_assistant", env="DATABASE_NAME")
    
    # LLM配置
    LLM_API_KEY: str = Field(default="", env="LLM_API_KEY")
    LLM_API_BASE: str = Field(default="https://api.openai.com/v1", env="LLM_API_BASE")
    LLM_MODEL: str = Field(default="gpt-3.5-turbo", env="LLM_MODEL")
    LLM_TIMEOUT: int = Field(default=60, env="LLM_TIMEOUT")
    LLM_TEMPERATURE: float = Field(default=0.7, env="LLM_TEMPERATURE")
    LLM_MAX_TOKENS: int = Field(default=1000, env="LLM_MAX_TOKENS")
    
    # MCP配置
    MCP_CLIENT_PATH: str = Field(default="../MCP_Client", env="MCP_CLIENT_PATH")
    MCP_SERVERS_PATH: str = Field(default="../MCP_Client/config/mcp_servers.json", env="MCP_SERVERS_PATH")
    
    # JWT配置
    JWT_SECRET: str = Field(default="your-secret-key", env="JWT_SECRET")
    JWT_ALGORITHM: str = Field(default="HS256", env="JWT_ALGORITHM")
    JWT_EXPIRATION: int = Field(default=60 * 24 * 7, env="JWT_EXPIRATION")  # 7天

    class Config:
        env_file = ".env"
        env_file_encoding = 'utf-8'
        extra = "ignore"
        case_sensitive = False
        
    def __init__(self, **data):
        super().__init__(**data)
        # 强制检查并设置数据库URL为MySQL
        if not self.DATABASE_URL.startswith('mysql'):
            # 强制设置为预期的MySQL URL
            self.DATABASE_URL = "mysql+pymysql://root:password@host:3306/ai_assistant"
            self.DB_URL = f"mysql+pymysql://{self.DB_USER}:{self.DB_PASSWORD}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"

settings = Settings()
```

### .env 文件示例
```
# 应用基础配置
APP_NAME=FullVoiceAI
ENV=development
DEBUG=true
PORT=3000

# 数据库配置
DB_USER=myuser
DB_PASSWORD=mypassword
DB_HOST=localhost
DB_PORT=3306
DB_NAME=voiceai

# 认证配置
JWT_SECRET=your-super-secret-key-here
JWT_ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=10080  # 7天

# LLM配置
LLM_PROVIDER=openai
LLM_API_KEY=your-openai-api-key
LLM_MODEL=gpt-4o
# LLM_API_BASE=https://api.openai.com/v1  # 可选，自定义API基础URL

# MCP配置
MCP_SCRIPT_PATH=/path/to/mcp/script.py
MCP_MAX_RETRY=3
MCP_TIMEOUT_MS=30000
```

**注意**: 详细的环境变量配置说明和API接口定义请参考专门的对接文档。

---

## 5. 数据库模型与迁移
### 5.1 SQLAlchemy 模型
#### User 模型
```python
# models/user.py
from sqlalchemy import Column, BigInteger, String, JSON, DateTime
from datetime import datetime
from utils.db import Base

class User(Base):
    __tablename__ = 'users'
    id = Column(BigInteger, primary_key=True, autoincrement=True)
    username = Column(String(64), unique=True, nullable=False)
    email = Column(String(128), unique=True, nullable=False)
    password_hash = Column(String(256), nullable=False)
    contacts = Column(JSON)
    wallets = Column(JSON)
    created_at = Column(DateTime, default=datetime.utcnow)
```

#### Tool 模型
```python
# models/tool.py
from sqlalchemy import Column, String, Enum, JSON, DateTime
from datetime import datetime
from utils.db import Base

class Tool(Base):
    __tablename__ = 'tools'
    tool_id = Column(String(64), primary_key=True)
    name = Column(String(128), nullable=False)
    type = Column(Enum('mcp', 'http'), nullable=False)
    description = Column(String(512))
    server_name = Column(String(64))  # 仅对MCP工具
    endpoint = Column(JSON, nullable=False)
    request_schema = Column(JSON, nullable=False)
    response_schema = Column(JSON, nullable=False)
    created_at = Column(DateTime, default=datetime.utcnow)
```

#### Session 模型
```python
# models/session.py
from sqlalchemy import Column, String, BigInteger, Enum, DateTime, ForeignKey
from sqlalchemy.sql import func
from utils.db import Base

class Session(Base):
    __tablename__ = 'sessions'
    session_id = Column(String(36), primary_key=True)
    user_id = Column(BigInteger, ForeignKey('users.id'), nullable=False)
    status = Column(Enum('interpreting', 'waiting_confirm', 'executing', 'done', 'error'), nullable=False)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())
```

### 5.2 Alembic 迁移
- 初始化迁移：
  ```bash
  cd backend
  alembic init alembic
  ```

- 创建迁移脚本：
  ```bash
  alembic revision --autogenerate -m "创建初始表"
  ```

- 执行迁移：
  ```bash
  alembic upgrade head
  ```

- 示例迁移脚本 (tools表添加server_name字段)：
  ```python
  # alembic/versions/xxxx_add_server_name_to_tools.py
  def upgrade():
      op.add_column('tools', sa.Column('server_name', sa.String(64), nullable=True))

  def downgrade():
      op.drop_column('tools', 'server_name')
  ```

---

## 6. 核心服务组件

### 6.5 统一执行服务（Unified Execution Service）

统一执行服务是系统重构后新增的核心组件，位于 `services/unified_execution_service.py`，主要解决以下问题：

#### 6.5.1 解决的核心问题
- **session_id为null问题**：确保每个请求都有有效的会话ID
- **执行路径不一致**：统一execute和confirm接口的处理逻辑
- **数据库会话冲突**：通过SessionManager管理数据库会话状态
- **响应超时处理**：统一的超时控制和错误处理机制
- **响应格式一致性**：确保所有接口返回格式统一

#### 6.5.2 核心功能

```python
class UnifiedExecutionService:
    """统一执行服务
    
    整合execute和confirm接口的核心逻辑，提供统一的执行入口
    """
    
    def __init__(self):
        self.execute_service = ExecuteService()
        self.intent_service = IntentService()
        self.execution_timeout = 30  # 30秒超时
    
    async def execute_tool_unified(self, request: ExecuteRequest, user_id: int, db: AsyncSession) -> ExecuteResponse:
        """统一工具执行接口"""
        
    async def confirm_and_execute_unified(self, request: ConfirmRequest, user_id: int, db: AsyncSession) -> ConfirmResponse:
        """统一确认执行接口"""
```

#### 6.5.3 SessionManager会话管理器

```python
class SessionManager:
    """会话管理器 - 统一管理数据库会话状态"""
    
    async def create_session(self, user_id: int, db: AsyncSession) -> str:
        """创建新会话"""
        
    async def update_session_status(self, session_id: str, status: str, error_msg: str = None) -> None:
        """更新会话状态"""
        
    async def log_operation(self, session_id: str, operation: str, details: dict) -> None:
        """记录操作日志"""
```

#### 6.5.4 使用方式

统一执行服务被控制器层调用：

```python
# controllers/execute_controller.py
from app.services.unified_execution_service import UnifiedExecutionService

unified_execution_service = UnifiedExecutionService()

async def execute_tool(request: ExecuteRequest, db: AsyncSession, user_id: int):
    return await unified_execution_service.execute_tool_unified(request, user_id, db)

# controllers/intent_controller.py  
async def process_confirmation(request: ConfirmRequest, db: AsyncSession, user_id: int):
    return await unified_execution_service.confirm_and_execute_unified(request, user_id, db)
```

#### 6.5.5 优势
- **代码复用**：避免execute和confirm接口的重复逻辑
- **统一错误处理**：集中处理超时、异常等错误情况
- **会话状态管理**：确保会话状态的一致性和可追踪性
- **向后兼容**：保持API接口签名不变，前端无需修改
- **易于维护**：集中的业务逻辑便于后续优化和扩展

---

## 9. 身份认证（JWT）

系统使用JWT（JSON Web Token）进行用户身份认证和授权。所有需要保护的API接口都必须提供有效的JWT令牌。

### 9.1 认证流程

1. **用户登录**：用户通过用户名和密码登录，系统验证后返回JWT令牌
2. **令牌携带**：客户端在后续API请求中通过Authorization头携带Bearer令牌
3. **令牌验证**：服务器验证令牌的有效性和用户权限
4. **访问控制**：根据用户角色控制API访问权限

### 9.2 认证相关API

系统提供完整的用户认证API，包括登录、注册、获取用户信息等功能。详细的API接口定义请参考：[前后端对接与API规范](前后端对接与API规范.md)

### 9.3 受保护的API接口

以下API接口需要有效的JWT令牌：

| 接口 | 最低权限要求 | 说明 |
|------|-------------|------|
| `POST /api/v1/intent/interpret` | user+ | 意图解析 |
| `POST /api/v1/execute` | user+ | 工具执行 |
| `GET /api/v1/tools` | user+ | 获取工具列表 |
| `GET /api/v1/auth/me` | user+ | 获取当前用户信息 |
| `GET /api/v1/dev/tools` | developer+ | 开发者工具管理 |

### 9.4 用户角色权限

系统支持基于角色的访问控制（RBAC）：

- **user**: 普通用户，可以使用基本的AI功能
- **developer**: 开发者用户，可以管理和上传自定义工具
- **admin**: 管理员用户，拥有所有权限

### 9.5 JWT令牌配置

在`.env`文件中配置JWT相关参数：

```bash
# JWT配置
JWT_SECRET=your-super-secret-key-here
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=10080  # 7天
```

### 9.6 认证实现细节

#### 依赖注入
```python
# utils/security.py
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt

oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_PREFIX}/auth/token")

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> User:
    """验证JWT令牌并获取当前用户"""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    
    try:
        payload = jwt.decode(token, settings.JWT_SECRET, algorithms=[settings.JWT_ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            raise credentials_exception
    except JWTError:
        raise credentials_exception
    
    # 从数据库获取用户信息
    stmt = select(User).where(User.id == user_id)
    result = await db.execute(stmt)
    user = result.scalar_one_or_none()
    
    if user is None:
        raise credentials_exception
    
    return user
```

#### 路由保护
```python
# routers/interpret.py
@router.post("/interpret")
async def interpret_text(
    request: InterpretRequest,
    current_user: User = Depends(get_current_user),  # 强制认证
    db: AsyncSession = Depends(get_db)
):
    """意图解析接口 - 需要认证"""
    # 处理逻辑...
```

### 9.7 错误处理

认证相关的HTTP状态码：

- **401 Unauthorized**: 令牌无效、过期或缺失
- **403 Forbidden**: 用户权限不足
- **422 Unprocessable Entity**: 请求参数错误

**错误响应示例**：
```json
{
  "detail": "Could not validate credentials"
}
```

---

## 10. 集成测试与单元测试

### 10.1 认证测试
```python
# tests/test_auth.py
import pytest
from httpx import AsyncClient

@pytest.mark.asyncio
async def test_login_success(client: AsyncClient):
    response = await client.post("/api/v1/auth/token", data={
        "username": "testuser",
        "password": "testpass"
    })
    assert response.status_code == 200
    data = response.json()
    assert "access_token" in data
    assert data["token_type"] == "bearer"

@pytest.mark.asyncio
async def test_protected_endpoint_without_token(client: AsyncClient):
    response = await client.post("/api/v1/intent/interpret", json={
        "query": "hello",
        "user_id": "1",
        "session_id": null
    })
    assert response.status_code == 401

@pytest.mark.asyncio
async def test_protected_endpoint_with_token(client: AsyncClient, auth_headers):
    response = await client.post("/api/v1/intent/interpret", 
        json={"query": "hello", "user_id": "1", "session_id": null},
        headers=auth_headers
    )
    assert response.status_code == 200
```

---

## 11. 部署说明

### 生产环境部署
推荐使用启动脚本进行部署，它包含完整的环境检查和数据库连接验证：

```bash
# 生产环境启动
./start-backend.sh start

# 使用PM2管理进程（可选）
pm2 start "./start-backend.sh start" --name "ai-assistant-backend"
```

### Docker部署
```bash
# 构建镜像
docker build -t ai-assistant-backend .

# 运行容器
docker run -d -p 3000:3000 --env-file .env ai-assistant-backend
```

### 访问服务
- API文档: http://localhost:3000/docs
- 健康检查: http://localhost:3000/health

## 12. 手动启动方式（仅在必要时使用）

### 12.1 环境准备
1. 创建并激活虚拟环境：
   ```bash
   cd backend
   python -m venv venv
   source venv/bin/activate  # Linux/Mac
   # 或
   venv\Scripts\activate  # Windows
   ```

2. 安装依赖：
   ```bash
   pip install -r requirements.txt
   ```

3. 配置 `.env` 文件（从 `.env.example` 复制创建）：
   ```bash
   cp .env.example .env
   # 编辑 .env 并设置所有必需的环境变量
   ```

4. 迁移数据库：
   ```bash
   alembic upgrade head
   ```

### 12.2 启动服务
 ```bash
 # 开发模式，自动重载
 uvicorn app.main:app --reload --host 0.0.0.0 --port 3000
 
 # 生产模式
 uvicorn app.main:app --host 0.0.0.0 --port 3000
 ```
 
### 12.3 访问服务
 - Swagger UI: http://localhost:3000/docs
 - 健康检查: http://localhost:3000/health
 
## 13. MCP服务器管理

系统集成了MCP服务器管理器，自动启动和监控多个MCP服务器：

```bash
# MCP服务器配置文件位置
backend/app/mcp_servers.json

# 当前支持的MCP服务器：
# - playwright: 浏览器自动化工具
# - minimax-mcp-js: MiniMax API集成
# - amap-maps: 高德地图API
# - web3-rpc: Web3区块链API（可选启用）
```

**MCP服务器状态检查**：
```bash
# 查看MCP服务器状态
curl http://localhost:3000/api/v1/mcp/status

# 服务器监控间隔：60分钟（3600秒）
# 可在 app/services/mcp_manager.py 中调整 check_interval
```

### 11.2 测试账号

系统已预置不同角色的测试账号，详细的账号信息和使用说明请参考：[前后端对接与API规范](前后端对接与API规范.md)

## 12. 支持的工具类型

系统支持两种主要类型的工具：MCP工具和HTTP工具。

### 12.1 MCP工具
MCP (Multi-Chain Protocol) 工具是基于自定义协议的脚本工具，能够执行区块链相关操作和其他复杂任务。

- 要求配置 `server_name` 字段，指向对应的MCP服务器
- 支持完整的参数传递和结果解析
- 集成了多种MCP服务器，如Playwright、MiniMax API、地图API和Web3区块链API

### 12.2 HTTP工具
HTTP工具允许系统调用外部HTTP API来执行操作。目前支持以下平台类型：

1. **Dify**: 调用Dify平台上的AI应用
   - 支持 conversation_id 管理
   - 响应进行LLM总结处理，输出适合语音播报的内容

2. **Coze**: 调用Coze平台上的机器人
   - 要求在配置中提供 bot_id
   - 响应同样经过LLM总结处理

3. **通用HTTP**: 支持配置和调用任意HTTP API
   - 支持 GET, POST, PUT, PATCH, DELETE 等多种HTTP方法
   - 灵活配置头信息、认证方式（Bearer、ApiKey、Basic）
   - 支持响应结果路径提取（使用 result_path 字段）
   - 支持URL参数格式化和有效载荷配置
   - 对响应结果进行LLM总结处理，生成简洁易懂的语音反馈

### 12.3 示例工具配置
```sql
-- Dify工具示例
INSERT INTO tools (tool_id, name, type, description, endpoint, request_schema, response_schema)
VALUES (
    'dify-chat-default',
    'Dify AI助手',
    'http',
    '通用AI对话助手',
    '{
        "platform": "dify",
        "api_key": "your-dify-api-key",
        "app_id": "your-dify-app-id"
    }',
    '{"type": "object", "properties": {"query": {"type": "string"}}}',
    '{"type": "object", "properties": {"response": {"type": "string"}}}'
);

-- Coze工具示例
INSERT INTO tools (tool_id, name, type, description, endpoint, request_schema, response_schema)
VALUES (
    'coze-chat-default',
    'Coze机器人',
    'http',
    '通用AI对话机器人',
    '{
        "platform": "coze",
        "api_key": "your-coze-api-key",
        "bot_id": "your-coze-bot-id"
    }',
    '{"type": "object", "properties": {"query": {"type": "string"}}}',
    '{"type": "object", "properties": {"response": {"type": "string"}}}'
);

-- 通用HTTP工具示例
INSERT INTO tools (tool_id, name, type, description, endpoint, request_schema, response_schema)
VALUES (
    'weather-api',
    '天气预报API',
    'http',
    '查询城市天气预报',
    '{
        "platform": "generic",
        "api_key": "your-api-key-here",
        "app_config": {
            "url": "https://api.example.com/weather/{city}",
            "method": "GET",
            "auth_type": "Bearer",
            "headers": {"accept": "application/json"},
            "timeout": 20,
            "result_path": "data.forecast"
        }
    }',
    '{"type": "object", "properties": {"city": {"type": "string"}}}',
    '{"type": "object", "properties": {"forecast": {"type": "string"}}}'
);
```

## 13. 开发者Portal功能

### 13.1 已实现功能
- ✅ 工具管理：创建、编辑、删除、测试工具
- ✅ 应用管理：创建、配置、发布AI应用
- ✅ 权限控制：基于角色的访问控制（RBAC）
- ✅ MCP服务器监控：实时状态查看和管理
- ✅ 测试环境：内置测试账号和API测试界面

### 13.2 API接口列表
```bash
# 开发者Portal核心接口
GET    /api/v1/dev/tools          # 获取工具列表
POST   /api/v1/dev/tools          # 创建新工具
GET    /api/v1/dev/tools/{id}     # 获取工具详情
PUT    /api/v1/dev/tools/{id}     # 更新工具
DELETE /api/v1/dev/tools/{id}     # 删除工具
POST   /api/v1/dev/tools/{id}/test # 测试工具

GET    /api/v1/dev/apps           # 获取应用列表
POST   /api/v1/dev/apps           # 创建新应用
GET    /api/v1/dev/apps/{id}      # 获取应用详情
PUT    /api/v1/dev/apps/{id}      # 更新应用
DELETE /api/v1/dev/apps/{id}      # 删除应用
POST   /api/v1/dev/apps/{id}/publish # 发布应用

GET    /api/v1/mcp/status         # MCP服务器状态
```

## 14. 常见问题解决

### API 调用方式
- 所有 API 调用需要先登录获取 JWT token
- 在请求头中添加 `Authorization: Bearer <token>`
- 使用 POST 方法调用 `/api/v1/execute` 接口

### 数据库连接参数配置
- 检查 `backend/.env` 文件中的数据库配置
- 确保 MySQL 服务正在运行（当前使用MySQL数据库）
- 验证数据库连接字符串格式：`mysql+pymysql://user:password@host:port/database`
- 检查数据库用户权限和网络连接

### MCP 服务器启动与管理
- 使用环境变量配置 API Key：`AMAP_MAPS_API_KEY=xxx npx @amap/amap-maps-mcp-server`
- 确保 MCP 服务器在后台运行
- 检查端口冲突和网络连接

### 工具类型配置
- MCP 工具：使用 `mcp` 类型
- HTTP 工具：使用 `http` 类型（支持 Dify、Coze、通用 HTTP）
- 避免将 Dify/Coze 错误配置为 MCP 类型

## 15. 后续迭代规划
- `/api/v1/confirm` 多轮确认接口优化
- 并行/串联多工具调用支持  
- 集成 Prometheus + Grafana 监控  
- 缓存(`Redis`) 会话与工具元数据  
- 完善 CI/CD 与 Kubernetes 部署指南
- 开发者Portal前端界面优化
- 工具市场和分享功能
- 统一执行服务性能优化
- 会话管理器扩展功能

---

> 文档更新时间：2025-01-14  
> 文档负责人：后端团队 Lead  
> 最近更新：修正文件名、路径描述，新增统一执行服务说明

